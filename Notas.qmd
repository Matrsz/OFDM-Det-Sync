---
title: "Notas Proyecto Integrador"
author: "Matías Roqueta"
format:
  html: 
    embed-resources: true
    theme: superhero
jupyter: julia-1.7
---

```{julia}
#| echo: false
#| output: false 

using Plots, PlotThemes, LaTeXStrings
using OffsetArrays
using Unitful
using FFTW
using Kroki
using Base: Fix1, Fix2

pyplot()
theme(:juno)
default(;palette=:seaborn_pastel6, background_color="#1b3041")
j=im
```

## Transmisión OFDM en el estándar IEEE 802.11a

- PSDU: PHY Service Data Unit
- PPDU: PHY Protocol Data Unit

### TXVECTOR

El TXVECTOR es una serie de parámetros provistos por la capa MAC a la capa PHY para transmitir un PSDU. Mínimamente contiene los parámetros **DATARATE** Y **LENGTH**. En particular para OFDM contiene

| Parámetro | Valores | Descripción |
| --- | --- | --- |
| LENGTH | 1 - 4095 | El número de octetos que la capa MAC necesita transmitir |
| DATARATE | Distintas tasas según el espacio entre canales (20, 10 o 5 MHz) | La tasa de bits a la que se transmitirá la PSDU |
| SERVICE | Null | Siempre es Null |
| TXPWR_LEVEL_INDEX | 1-8 | Cual de los posibles TxPowerLevel definidos en la MIB serán usados en la transmisión |
| TIME_OF_DEPARTURE_REQUESTED | False o True | Determina si la capa MAC solicita tiempo de primer transmisión a la capa PHY |
| CH_BANDWIDTH_IN_NON_HT | Opcional: CBW20, CBW40, CBW80, CBW160, O CBW80+80 | Si está presente, modifica los primeros 7 bits de la secuencia de _scrambling_ |
| DYN_BANDWIDTH_IN_NON_HT | Opcional: Static o Dynamic | Si es presente, modifica los primeros 7 bits de la secuencia de _scrambling_ |

Transmitir una trama implica tomar una PSDU y codificarla en una PPDU que se transmite por el canal inalámbrico.

<!-- \begin{center}
\begin{bytefield}[bitformatting={\footnotesize\bfseries}]{40} 
\bitheader{0, 4, 5, 17, 18, 24, 40}\\
\bitbox{4}{RATE\\4 bits} & 
\bitbox{1}{\rotatebox{-90}{RES}} & 
\bitbox{12}{LENGTH\\12 bits} & 
\bitbox{1}{\rotatebox{-90}{PAR}} & 
\bitbox{6}{Tail\\6 bits} & 
\bitbox{16}{SERVICE\\16 bits}
\bitbox[]{2}{$\cdots$}
\end{bytefield}
\end{center} -->

```{julia}
#| echo: false
#| output: false

Diagram(:packetdiag, """
{
  default_linecolor = white
  default_node_color = none
  default_textcolor = white
  colwidth = 40
  node_height = 50
  node_width = 18
  default_fontsize = 18
  scale_interval = 8
  * RATE [len=4, label="RATE\n4 bits"]
  * RES [len=1, rotate=90]
  * LENGTH [len=12, label="LENGTH\n12 bits"]
  * PAR [len=1, rotate=90]
  * TAIL [len=6, label="TAIL\n6 bits"]
  * SERVICE [len=16, label="SERVICE\n16 bits"]
}""") |> Fix2(render, "svg") |> Fix1(write, "Images/packet.svg")
```

![PHY Header en el estándar 802.11a. RATE, un bit reservado, LENGTH, un bit de paridad, y TAIL corresponden al símbolo SIGNAL.](Images/packet.svg)

Los primeros 24 bits corresponden un símbolo OFDM, llamado SIGNAL. Se transmite:

- PHY Preamble: 12 símbolos OFDM
- SIGNAL: 1 símbolo OFDM
- DATA: N símbolos OFDM

```{julia}
#| echo: false
#| output: false

Diagram(:packetdiag, """
{
  default_linecolor = white
  default_node_color = none
  default_textcolor = white
  colwidth = 3
  node_height = 50
  node_width = 300
  default_fontsize = 18
  scale_interval = 1
  * PREAMBLE [len=1, label="PHY Preamble: 12 simbolos"]
  * SIGNAL [len=1, label="SIGNAL: 1 simbolo\nBPSK, Tasa = 1/2"]
  * DATA [len=1, label="DATA: N simbolos\nMod. y tasa según SIGNAL"]
}""") |> Fix2(render, "svg") |> Fix1(write, "Images/packet2.svg")
```

![PHY Preamble en el estándar 802.11a](Images/packet2.svg)

### PHY Preamble
El PHY Preamble se utiliza para motivos de sincronismo, consiste en:

- 10 iteraciones de una _short training symbol_ 
- Un _guard interval_ 
- 2 iteraciones de una _long training symbol_

```{julia}
#| echo: false
#| output: false

Diagram(:wavedrom, """
{ 
  config: {skin: 'narrow'},
  head: {text: ['tspan', {class:'muted h3'}, "PHY Preamble"]},
  signal: [
  { name: "",  wave: "x===========.=...=...=", data: ["t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9", "t10", "GI2", "T1", "T2"]}
  ], 
  foot: {tick: -1, every:10}
  }""") |> Fix2(render, "svg") |> Fix1(write, "Images/wave.svg")
```

![PHY Preamble en el estándar 802.11a, $t_i$ denota un _short training symbol_ y $T_i$ un _long training symbol_.](Images/wave.svg)

La duración del instante temporal en la figura depende del espaciamiento entre canales.

- 20 MHz $\rightarrow$ 0.8 $\micro$s
- 10 MHz $\rightarrow$ 1.6 $\micro$s (half-clocked)
- 5  MHz $\rightarrow$ 3.2 $\micro$s (quarter-clocked)

De ahora en más se trabaja con los valores correspondientes a 20 MHz

```{julia}
#| echo: false
#| output: false

T_TR = 100u"ns"
Δ_F = 20u"MHz"/64
T_SHORT = 8u"μs"
T_LONG = 8u"μs"
T_GI2 = 1.6u"μs"

function w(T, t)
    if t < -T_TR/2 
        return 0
    elseif t < T_TR/2
        return sin(π/2*(0.5+t/T_TR))^2
    elseif t < T-T_TR/2
        return 1
    elseif t < T+T_TR/2
        return sin(π/2*(0.5-(t-T)/T_TR))^2
    else
        return 0
    end
end

t = range(0u"μs", 8u"μs", length=5000)
```

### Short Training Symbol
El _short training symbol_ consiste en 12 subportadoras moduladas por los elementos de la secuencia $S$ del siguiente aspecto.
$$
S_{-26,26} = \sqrt{\frac{13}{6}}\begin{bmatrix} 0 & 0 & 1+j & 0 & 0 & 0 & –1–j & 0 & 0 & \cdots \end{bmatrix}
$$
Solo los índices múltiplos de 4 tienen señal (que puede ser "$j+1$" o "$-j-1$"), el factor multiplicativo normaliza la potencia media del símbolo OFDM, ya que este usa 12 de las 52 subportadoras: -24, -20, -16, -12, -8, -4, 4, 8, 12, 16, 20, 24.

La señal se construye a partir de

$$
 r_{SHORT}(t) = w_{TSHORT}(t) \sum_{k=-N_{ST}/2}^{N_{ST}/2}S_ke^{j2\pi k \Delta_F t}
$$

```{julia}
#| echo: false
#| fig-cap: _short training sequence_ en el dominio temporal

S = OffsetArray(sqrt(13/6).*[0, 0, 1+j, 0, 0, 0, -1-j, 0, 0, 0, 1+j, 0, 0, 0, -1-j, 0, 0, 0, -1-j, 0, 0, 0, 1+j, 0, 0, 0, 0,
0, 0, 0, -1-j, 0, 0, 0, -1-j, 0, 0, 0, 1+j, 0, 0, 0, 1+j, 0, 0, 0, 1+j, 0, 0, 0, 1+j, 0,0], -26:26)
r_s(t) = w(T_SHORT,t)*sum(S[k]*exp(j*k*2π*Δ_F*t) for k in eachindex(S))

rs = r_s.(t)
p1 = plot(t, real(rs), ylabel="canal I", xlabel="", xticks=[], title=L"r_{SHORT}")
p2 = plot(t, imag(rs), ylabel="canal Q", xticks=0:0.8:8, xlabel=L"t")
for i in 0:0.8:8
    plot!(p1, [i,i], [-10,10], linestyle=:dash, linecolor=:silver)
    plot!(p2, [i,i], [-10,10], linestyle=:dash, linecolor=:silver)
end

plot(p1, p2, layout=(2,1), legend=false, size=(800,300), background_color="#1b3041")
```

### Long Training Symbol
El _long training symbol_ consiste en 53 subportadoras (las 52 disponibles más el valor 0 en continua), moduladas por los elementos de la secuencia $L$ del siguiente aspecto:
$$
L_{-26,26} = \begin{bmatrix} 1 & 1 & –1 & –1 & 1 & 1 & –1 & 1 & \cdots \end{bmatrix}
$$

La señal se construye a partir de
$$
 r_{LONG}(t) = w_{TLONG}(t) \sum_{k=-N_{ST}/2}^{N_{ST}/2}L_ke^{j2\pi k \Delta_F (t-T_{GI2})}
$$

```{julia}
#| echo: false
#| fig-cap: _long training sequence_ en el dominio temporal

L = OffsetArray([1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 0,
1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1, -1, 1, 1, 1, 1], -26:26)

r_l(t) = w(T_LONG,t)*sum(L[k]*exp(j*k*2π*Δ_F*(t-T_GI2)) for k in eachindex(L))

rl = r_l.(t)

p1 = plot(t, real(rl), ylabel="canal I", xlabel="", xticks=[], title=L"r_{LONG}")
p2 = plot(t, imag(rl), ylabel="canal Q", xticks=[0,1.6,4.8,8], xlabel=L"t")

for i in [0,1.6,4.8,8]
    plot!(p1, [i,i], [-10,10], linestyle=:dash, linecolor=:silver)
    plot!(p2, [i,i], [-10,10], linestyle=:dash, linecolor=:silver)
end

plot(p1, p2, layout=(2,1), legend = false, size=(800,300), background_color="#1b3041")
```


Finalmente las señales se concatenan para formar el PHY preamble
$$
r_{PREAMBLE}(t) = r_{SHORT}(t)+r_{LONG}(t-T_{SHORT})
$$

```{julia}
#| echo: false
#| fig-cap: PHY Preamble en el dominio temporal

r_p(t) = r_s(t)+r_l(t-T_SHORT)

tiks = [0:0.8:8..., [1.6,4.8,8].+8...]

t = range(0u"μs", 16u"μs", length=5000)
rp = r_p.(t)

p1 = plot(t, real(rp), ylabel="canal I", xlabel="", xticks=[], title=L"r_{PREAMBLE}")
p2 = plot(t, imag(rp), ylabel="canal Q", xticks=tiks, xlabel=L"t")

for i in tiks
    plot!(p1, [i,i], [-10,10], linestyle=:dash, linecolor=:silver)
    plot!(p2, [i,i], [-10,10], linestyle=:dash, linecolor=:silver)
end

plot(p1, p2, layout=(2,1), legend = false, size=(800,300), background_color="#1b3041")
```

### Parámetros Temporales 

| Parámetros | Significado | Valor a 20 MHz | Nota | 
| --- | --- | --- | --- |
| $\Delta_F$ | Espacio entre subportadoras | 0.3125 MHz | $\dfrac{20\;\mathrm{MHz}}{64}$ |
| $T_{FFT}$ | Período de FFT/IFFT | 3.2 $\micro$s | $\dfrac{1}{\Delta_F}$ | 
| $T_{PREAMBLE}$ | Duración del PHY Preamble | 16 $\micro$s | $T_{SHORT}+T_{LONG}$ |
| $T_{SIGNAL}$ | Duración del símbolo SIGNAL | 4 $\micro$s | $T_{GI}+T_{FFT}$ |
| $T_{GI}$ | Duración del guard interval | 0.8 $\micro$s | $\dfrac{T_{FFT}}{4}$ |
| $T_{GI2}$ | Guard interval de la secuencia de entrenamiento | 1.6 $\micro$s | $\dfrac{T_{FFT}}{2}$ |
| $T_{SYM}$ | Intervalo de símbolo | 4 $\micro$s | $T_{GI}+T_{FFT}$ |
| $T_{SHORT}$ | Duración de la _short training sequence_ | 8 $\micro$s | $10 \times \dfrac{T_{FFT}}{4}$ |
| $T_{LONG}$ | Duración de la _long training sequence_ | 8 $\micro$s | $T_{GI2}+2\times T_{FFT}$ |

La función $w_T(t)$ es la función ventana temporal, definida por:

$$
  w_T(t) = \left\{
    \begin{aligned}
      \;&\sin^2\left[\tfrac{\pi}{2} \left(0.5 + \tfrac{t}{T_{TR}}\right)\right] \qquad &-\tfrac{T_{TR}}{2} < &t < \tfrac{T_{TR}}{2} \\
      \;&1 \qquad & \tfrac{T_{TR}}{2} \le &t < T-\tfrac{T_{TR}}{2} \\
      \;&\sin^2\left[\tfrac{\pi}{2} \left(0.5 - \tfrac{t-T}{T_{TR}}\right)\right] \qquad & T-\tfrac{T_{TR}}{2} \le &t < T+\tfrac{T_{TR}}{2} \\
    \end{aligned}
  \right.
$$
En donde $T_{TR}$ del orden de los 100 ns es el tiempo de transición, la función $w_T(t)$ es efectivamente un pulso de duración $T$ con transición suave.


### PHY Header

Todo se construye a partir del TXVECTOR

- RATE, LENGTH: Obtenidos del TXVECTOR, se le agrega un bit de paridad par y un TAIL de 000000. Son codificados por un código convolucional a tasa 1/2, y asigados un único símbolo ODFM llamado SIGNAL que es transmitido con codificación BPSK.
- A partir de RATE del TXVECTOR se calcula
  - $R$: la tasa de codificación
  - $N_{DBPS}$: el número de bits _de datos_ por símbolo OFDM
  - $N_{CBPS}$: el número de bits _codificados_ por símbolo OFDM
  - $N_{BPSC}$: el número de bits por sub-portadora OFDM
- El PSDU se concatena a SERVICE de TXVECTOR. Se extiende con bits 0 (mínimo 6) hasta completar N símbolos OFDM. Esto es la secuencia de símbolos DATA.
- En función de si CH_BANDWIDTH_IN_NON_HT está o no presente en TXVECTOR, el _scrambler_ se inicializa con una semilla pseudoaleatoria o usando este campo.
- Se aplica XOR de la secuencia de _scrambling_ con los bits de DATA. Los 6 últimos bits luego se remplazan con 0. Estos últimos bits retornarán el codificador convolucional al estado inicial.
- La secuencia DATA se codifica con un código convolucional a tasa $R=1/2$, y luego se perfora para alcanzar la tasa definida en el parámetro RATE de TXVECTOR.
- La secuencia codificada se divide en tramas de $N_{CBPS}$ bits. Cada grupo se convierte en un símbolo según la tabla de modulación.
- El número total de subportadoras es 52, indexadas de -26 a 26. 48 de ellas transmiten datos y 4 subportadoras se insertan a modo de piloto en índices -21, -7, 7, y 21. 
- A cada grupo de 52 subportadoras se aplica la IFFT, se adjunta el prefijo cíclico, y se usa una ventana temporal para truncar la forma resultante al largo de un símbolo ODFM.
- Los símbolos OFDM se concatenan a el símbolo SIGNAL, uno atrás del otro.
- La señal en banda base se eleva a RF con frecuencia central del canal de operación y se transmite. 

### Parámetros dependientes de la modulación

| Modulación | Tasa código $R$ | $N_{BPSC}$ | $N_{CBPS}$ | $N_{DBPS}$ | 
| --- | --- | --- | --- | --- |
| BPSK | 1/2 | 1 | 48 | 24 |
| BPSK | 3/4 | 1 | 48 | 36 |
| QPSK | 1/2 | 2 | 96 | 48 |
| QPSK | 3/4 | 2 | 96 | 72 |
| 16-QAM | 1/2 | 4 | 192 | 96 |
| 16-QAM | 3/4 | 4 | 192 | 144 |
| 64-QAM | 2/3 | 6 | 288 | 192 |
| 64-QAM | 3/4 | 6 | 288 | 216 |

: Número de bits por subportadora, Número de bits codificados por símbolo ODFM, y número de bits de datos por símbolo en función de la modulación y la tasa de código

### RATE

Los bits de este campo se asignan según la tasa de transmisión. No pueden tomar cualquier valor, sino alguno de los presentes en la siguiente tabla

| RATE | Tasa de bits con 20 MHz entre canales |
| --- | --- |
| 1101 | 6  MHz/s | 
| 1111 | 9  MHz/s | 
| 0101 | 12 MHz/s | 
| 0111 | 18 MHz/s | 
| 1001 | 24 MHz/s | 
| 1011 | 36 MHz/s | 
| 0001 | 48 MHz/s | 
| 0011 | 54 MHz/s | 
: Tasa de bits para 20 MHz entre canales. Es 1/2 de la registrada con 10 MHz entre canales, y 1/4 de la registrada con 5 MHz entre canales

### LENGTH

Es un número en formato _unsigned integer_ de 12 bits que indica el número de octetos que se transmitirán. Se transmite empezando por el bit menos significativo (LSB).

## Sincronización OFDM

## Modelo Canal OFDM

Para transmitir datos en un canal OFDM se hace en bloques de $N_T$ símbolos, los datos a transmitir se necesita subdividir en tramas de longitud $N_C$

- $N_C$: Longitud en símbolos de datos de una trama
- $L$: Longitud en símbolos de la ISI
- $N_T$: Longitud de símbolos transmitidos por el canal. Para no tener ISI se necesita $N_T = N_C+L-1$

La transmisión de datos en un canal OFDM sigue el siguiente método:

- A un vector de datos $\mathbf{\tilde x}$ de longitud $N_C$ se le aplica la transformada inversa de Fourier, obteniendo 
$$\mathbf x = \mathcal F^{-1}[\mathbf{\tilde x}]$$
- A $\mathbf x$ se le agregan $L-1$ símbolos de prefijo cíclico, obteniendo el vector $\mathbf{\bar x}$ de longitud $N_T$.
$$ \mathbf{\bar x} = \begin{bmatrix}x_{N_C-L+1} & \cdots & x_{N_C-1} & x_0 & \cdots & x_{N_C-1} \end{bmatrix} $$
- El vector $\mathbf{\bar x}$ se transmite por el canal $\mathbf h$, obteniendo 
$$\mathbf{\bar y} = \mathbf h \ast \mathbf{\bar x} + \mathbf w$$
- Se ignora el prefijo de $\mathbf{\bar y}$, quedándose únicamente con los últimos $N_C$ símbolos
$$\mathbf y = \begin{bmatrix}\bar y_L & \cdots & \bar y_{N_C+L-1}\end{bmatrix}$$
- A $\mathbf y$ se le aplica la transformada de Fourier, obteniendo el vector final recibido
$$\mathbf{\tilde y} = \mathcal F[\mathbf{y}]$$

```{julia}
#| echo: false
#| output: false

Diagram(:blockdiag, """
{
  default_fontsize = 20
  node_height = 70
  node_width = 100
  default_group_color = none
  default_linecolor = white
  default_textcolor = white
  default_node_color = none

  IFFT [label="IFFT"]
  CY [label="Cyclic\nPrefix"]
  CH [label="Channel"]
  RP [label="Remove\nPrefix"]
  FFT [label="FFT"]
  TX [label="TX", width=70, shape=circle]
  RX [label="RX", width=70, shape=circle]
  
  TX -> IFFT 
  group{ 
    IFFT -> CY 
  group {
    orientation = portrait
    CY -> CH -> RP [thick]
  }
  RP -> FFT
  }
  FFT -> RX
}""") |> Fix2(render, "svg") |> Fix1(write, "Images/channel.svg")
```

![Estructura de un canal OFDM](Images/channel.svg)

La relación final entre el vector transmitido $\mathbf{\tilde x}$, el vector recibido $\mathbf{\tilde y}$, y el canal $\mathbf h$ es
$$
  \mathbf{\tilde y} = \mathbf{\tilde h}^\star \mathbf{\tilde x} + \mathbf{\tilde w}
$$
En donde (asumo, porque el Tse no es super explícito al respecto) que $\mathbf{\tilde h} = \mathcal F[\mathbf h]$. Efectivamente se usa la identidad
$$
  \mathbf y = \mathbf h \ast \mathbf x + \mathbf w \longleftrightarrow \mathbf{\tilde y} = \mathbf{\tilde h}^\star \mathbf{\tilde x} + \mathbf{\tilde w}
$$

### Prefijos cíclicos

Esto no está en el Tse, pero agregar o quitar prefijos cíclicos podría ser interpretado como operaciones matriciales

Ej con $N_C=5$ y $L=4$ entonces $N_T=8$

- Agregar prefijo: 
$$
\begin{bmatrix}
x_2 \\ x_3 \\ x_4 \\ x_0 \\ x_1 \\ x_2 \\ x_3 \\ x_4
\end{bmatrix} = 
\begin{bmatrix}
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 1 \\
1 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x_0 \\ x_1 \\ x_2 \\ x_3 \\ x_4
\end{bmatrix}
$$

- Quitar prefijo: 
$$\begin{bmatrix}
y_3 \\ y_4 \\ y_5 \\ y_6 \\ y_7
\end{bmatrix} = 
\begin{bmatrix}
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
y_0 \\ y_1 \\ y_2 \\ y_3 \\ y_4 \\ y_5 \\ y_6 \\ y_7
\end{bmatrix}
$$

Ya que los demás procedimientos, FFT, IFFT, convolución circular, eventualmente códigos de corrección de errores, eventualmente entrelazado (tampoco lo menciona el Tse), etc son operaciones matriciales, esta interpretación puede resultar útil